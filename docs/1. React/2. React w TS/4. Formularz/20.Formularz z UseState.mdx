---
title: Formularz z useState
---
c.d projektu z poprzedniej strony

# Hook `useState`
:::info useState
- to *hook* (czyli specjalny rodzaj funkcji) w React, który pozwala na zarządzanie stanem (ang. *state*) w komponentach funkcyjnych.
- dzięki niemu możemy przechowywać i aktualizować wartości, które mogą się zmieniać w czasie działania aplikacji.

:::

Syntaktyka hooka `useState`
```js
const [state, setState] = useState(initialValue);`
```
- `state` aktualna wartość stanu.
- `setState` funkcja do aktualizacji stanu.
- `initialValue` wartość początkowa (np. "", 0, {}).



## `useState` obsługujący `input`
```typescript jsx
import './App.css'
import {type ChangeEvent, type FormEvent, useState} from "react";

function App() {
    const [textInput, setTextInput] = useState("to jest z useState")

    //....

    function handleTextInputChange(e: ChangeEvent<HTMLInputElement>){
        setTextInput(e.target.value);
        console.log(textInput);
    }

  return (
    <>
         <form onSubmit={handleSubmit}>
            <input
                type={"text"}
                value = {textInput}
                onChange={handleTextInputChange}
                placeholder={"Wprowadź jakiś tekst"}
            />

             <button type="submit" >Submit</button>
         </form>
    </>
  )
}

export default App
```

## Dane z `input` w konsoli
Wyświetlimy zawartość pola do wprowadzania danych w konsoli.

Zmieniamy ciało funkcji:
```tsx
function handleSubmit(event: SyntheticEvent<HTMLFormElement>) {
        event.preventDefault();

        console.log(event.target);
        console.log(`Wartość z inputa to: ${textInput}`)
        setTextInput("") // czyścimy pole input

    }
```




## Mała walidacja
Jeśli pole input będzie puste, to przycisk `submit` będzie zablokowany
```tsx
   <form onSubmit={handleSubmit}>
            <input
                type={"text"}
                value ={textInput}
                onChange={handleTextInputChange}
                placeholder={"Wprowadź jakiś tekst"}
            />

            {textInput.length < 3  && textInput.length > 0 && (
                <span style={{color: 'red', margin:"0 10px"}}>Text jest za krótki </span>
            )}
            <button disabled={textInput.length < 3} type="submit">Submit</button>
        </form>

```

## Dodajemy CheckBoxa i więcej walidacji
```tsx
    <label>
        <input
            type="checkbox"
            checked={hasAgreed}       // Tu nie ma "value", jest "checked"
            onChange={handleCheckboxChange}
        />
        Akceptuję regulamin
    </label>

{/* Button zablokowany, jeśli brak zgody LUB tekst za krótki */}
    <button type="submit" disabled={!hasAgreed || textInput.length < 3}>
        Submit
    </button>
```

### Brakuje nam funkcji `handleCheckboxChange` i `hasAgreed`
1. Podtrzebujemy dodatkowego `useState` do obsługi checkboxa:
```tsx

function App() {

    const [hasAgreed, setHasAgreed] = useState<boolean>(false);

//...
```

2. Potrzebujemy funkcji obsługującej zmiane w polu checkboxa:
```tsx

   function handleCheckboxChange(e: ChangeEvent<HTMLInputElement>) {
        // Tu nie używamy e.target.value, tylko e.target.checked!
        console.log(e.target.checked);
        setHasAgreed(e.target.checked);
    }

```


## Lista rozwijana `<select>`, czyli który owoc wolisz

### Dodamy obsługę stanu i obsługę zmiany stanu
:::important Zwróć uwagę
`e: ChangeEvent<HTMLSelectElement>` - pracuje na `select` a nie `input`

:::

```tsx
 // 1. Stan (możemy ustawić domyślną wartość, np. "orange")
    const [fruit, setFruit] = useState("orange");

// 2. Handler - to samo co przy tekście!
    function handleSelectChange(e: ChangeEvent<HTMLSelectElement>) {
        console.log(e.target.value);
        setFruit(e.target.value);
    }
```

### Dodajemy `select` do formularza
```tsx
    <label>
        Wybierz ulubiony owoc:
        <select
            value={fruit}
            onChange={handleSelectChange}
            style={{marginLeft: "10px"}}
            >
            <option value={"apple"}>Jabłko</option>
            <option value={"orange"}>Pomarańcza</option>
            <option value={"banana"}>Banan</option>
        </select>
    </label>

    <button disabled={!hasAgreed || textInput.length < 3} type="submit">Submit</button>

```

## Radiobuttony, czyli jak chcesz płacić

### Definiujemy stan
Mamy opcje: "Karta", "BLIK", "Przelew".
`const [paymentMethod, setPaymentMethod] = useState("blik"); // Domyślnie BLIK`

### Definiujemy handler
```tsx
function handlePaymentChange(e: ChangeEvent<HTMLInputElement>) {
    setPaymentMethod(e.target.value);
    console.log(e.target.value)
}
```

### Definiujemy JSX
```tsx
 <div>
    <p>Wybierz formę płatności:</p>
    <label>
        <input
            type="radio"
            name="payment"            // Ważne: grupuje przyciski dla przeglądarki
            value="blik"              // To trafi do stanu
            checked={paymentMethod === "blik"} // Logika: Czy ja jestem wybrany?
            onChange={handlePaymentChange}
        />
        BLIK
    </label>


{/* Opcja 2: Karta */}
    <label style={{ marginLeft: "15px" }}>
        <input
            type="radio"
            name="payment"
            value="card"
            checked={paymentMethod === "card"} // Czy stan to "card"?
            onChange={handlePaymentChange}
        />
        Karta
    </label>

    {/* Opcja 3: Gotówka */}
    <label style={{ marginLeft: "15px" }}>
        <input
            type="radio"
            name="payment"
                        value="cash"
                        checked={paymentMethod === "cash"}
                        onChange={handlePaymentChange}
                    />
                    Gotówka
    </label>
</div>


```























