---
title: Agregacja w E-sporcie (Pipeline)
sidebar_label: Projekt Liga E-sportowa
description: Zaawansowane ≈ÇƒÖczenie danych, liczenie statystyk i grupowanie.
---

import Admonition from '@theme/Admonition';

# Projekt: Analityka Ligi E-sportowej üéÆ
- W tym scenariuszu wcielamy siƒô w rolƒô analityk√≥w danych.
- Naszym celem jest wy≈Çonienie najlepszej dru≈ºyny na podstawie wynik√≥w poszczeg√≥lnych graczy.
- U≈ºyjemy do tego **Aggregation Pipeline**.

W bazie danych *liga* bƒôdziemy mieli dwie kolekcje:
1.  **`teams`**  baza organizacji.
2.  **`players`** zawodnicy ze statystykami z ostatniego meczu.

## 1. Przygotowanie Danych (Seed Data)
* Skopiuj poni≈ºsze polecenia do swojego terminala (mongosh) lub Compassa.
* Zauwa≈º, ≈ºe u≈ºywamy czytelnych ID (slug√≥w) dla dru≈ºyn, aby ≈Çatwiej ≈õledziƒá relacje.
* Mo≈ºna w Mongo nadpisaƒá domy≈õlne pole "_id" np. stringiem.

### Kolekcja `teams`
```javascript
db.teams.insertMany([
  { "_id": "navi", "name": "Natus Vincere", "region": "EU", "founded": 2009 },
  { "_id": "t1", "name": "T1", "region": "KR", "founded": 2003 },
  { "_id": "g2", "name": "G2 Esports", "region": "EU", "founded": 2014 }
])
```

### Kolekcja `players`
```js
db.players.insertMany([
  { "nickname": "s1mple", "team_id": "navi", "role": "Sniper", "stats": { "kills": 25, "deaths": 10, "assists": 5 } },
  { "nickname": "b1t", "team_id": "navi", "role": "Rifler", "stats": { "kills": 18, "deaths": 12, "assists": 8 } },
  { "nickname": "Faker", "team_id": "t1", "role": "Mid", "stats": { "kills": 10, "deaths": 2, "assists": 15 } },
  { "nickname": "Zeus", "team_id": "t1", "role": "Top", "stats": { "kills": 12, "deaths": 5, "assists": 10 } },
  { "nickname": "Caps", "team_id": "g2", "role": "Mid", "stats": { "kills": 20, "deaths": 20, "assists": 10 } },
  { "nickname": "FreeAgent_01", "team_id": null, "role": "Support", "stats": { "kills": 5, "deaths": 5, "assists": 20 } }
])

```

### Cel biznesowy: Ranking efektywno≈õci
Nasz szef chce raportu, kt√≥ry:
1. Odrzuci graczy bez dru≈ºyny (`team_id: null`).
2. Po≈ÇƒÖczy gracza z nazwƒÖ jego dru≈ºyny.
3. Obliczy wsp√≥≈Çczynnik KDA (Kills + Assists / Deaths) dla ka≈ºdego gracza.
4. Zgrupuje wyniki, aby pokazaƒá ≈õrednie KDA ca≈Çej dru≈ºyny.
5. Posortuje dru≈ºyny od najlepszej do najgorszej.

To klasyczny przyk≈Çad *ETL* (*Extract*, *Transform*, *Load*) wykonywany w locie przez bazƒô danych.


### Budujemy Pipeline
- W *Compass* wybieramy kolekcjƒô `players` i "zak≈Çadkƒô" *Aggregations".
- Bƒôdzie po kolei dodawali odpowiednie *stage*, czyli bƒôdziemy budowali *pipeline*

1. Filtrowanie - `$match`
```js
{
   "team_id": { $ne: null }
}
```


2. ≈ÅƒÖczenie - `$lookup`
```js
{
  from: "teams",
  localField: "team_id",
  foreignField: "_id",
  as: "team_info"
}
```

3. Sp≈Çaszczamy - `$unwind`
```js
{
  path: "$team_info",
}
```

4. Obliczanie wsp√≥≈Çczynnika KDA - `addFields`
Dodajemy wirtualne pole `kda_ratio`.
```js
{
    kda_ratio :{
        $divide: [
            {$add: ["$stats.kills", "$stats.assists"]},
            {$max: ["$stats.deaths", 1]}
        ]
    }
}
```
`{$max: ["$stats.deaths", 1]}` to zabezpieczenie przed sytuacjƒÖ, gdy `stats.deaths` mia≈Çby warto≈õƒá `0`.

5. Grupowanie wynik√≥w - `$group`
Obliczamy ≈õredniƒÖ `kda` dla ka≈ºdej dru≈ºyny
```js
{
  "_id": "$team_info.name",
  "avg_tea_kda": { $avg: "$kda_ratio" },
  "players_count": {$sum: 1}
}

```

6. Sortujemy od najwy≈ºszegp wyniku `$sort`
```js
{
  "avg_team_kda": 1
}
```

Ca≈Çe zapytanie:
```js
db.players.aggregate([
  { $match: { team_id: { $ne: null } } },
  {
    $lookup: {
      from: "teams",
      localField: "team_id",
      foreignField: "_id",
      as: "team_info"
    }
  },
  { $unwind: "$team_info" },
  {
    $addFields: {
      kda_ratio: {
        $divide: [
          { $add: ["$stats.kills", "$stats.assists"] },
          { $max: ["$stats.deaths", 1] }
        ]
      }
    }
  },
  {
    $group: {
      _id: "$team_info.name",
      avg_team_kda: { $avg: "$kda_ratio" },
      player_count: { $sum: 1 }
    }
  },
  { $sort: { avg_team_kda: 1 } }
])

```










